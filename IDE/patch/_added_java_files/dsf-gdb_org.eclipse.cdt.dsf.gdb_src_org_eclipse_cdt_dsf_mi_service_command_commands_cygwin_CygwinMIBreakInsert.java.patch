diff --git a/dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/mi/service/command/commands/cygwin/CygwinMIBreakInsert.java b/dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/mi/service/command/commands/cygwin/CygwinMIBreakInsert.java
new file mode 100644
index 0000000000..b3a1278811
--- /dev/null
+++ b/dsf-gdb/org.eclipse.cdt.dsf.gdb/src/org/eclipse/cdt/dsf/mi/service/command/commands/cygwin/CygwinMIBreakInsert.java
@@ -0,0 +1,46 @@
+/********************************************************************************
+ * Copyright (c) 2024 徐持恒 Xu Chiheng
+ *
+ * This program and the accompanying materials are made available under the
+ * terms of the Eclipse Public License 2.0 which is available at
+ * http://www.eclipse.org/legal/epl-2.0.
+ *
+ * SPDX-License-Identifier: EPL-2.0
+ ********************************************************************************/
+
+package org.eclipse.cdt.dsf.mi.service.command.commands.cygwin;
+
+import org.eclipse.cdt.core.Cygwin;
+import org.eclipse.cdt.dsf.debug.service.IBreakpoints.IBreakpointsTargetDMContext;
+import org.eclipse.cdt.dsf.mi.service.command.commands.MIBreakInsert;
+
+public class CygwinMIBreakInsert extends MIBreakInsert {
+
+	public CygwinMIBreakInsert(IBreakpointsTargetDMContext ctx, String func, boolean allowPending) {
+		this(ctx, false, false, null, 0, func, "0", allowPending); //$NON-NLS-1$
+	}
+
+	public CygwinMIBreakInsert(IBreakpointsTargetDMContext ctx, boolean isTemporary, boolean isHardware,
+			String condition, int ignoreCount, String line, String tid, boolean allowPending) {
+		this(ctx, isTemporary, isHardware, condition, ignoreCount, line, tid, false, false, allowPending);
+	}
+
+	public CygwinMIBreakInsert(IBreakpointsTargetDMContext ctx, boolean isTemporary, boolean isHardware,
+			String condition, int ignoreCount, String location, String tid, boolean disabled, boolean isTracepoint,
+			boolean allowPending) {
+		super(ctx, isTemporary, isHardware, condition, ignoreCount, convertLocation(location), tid, disabled,
+				isTracepoint, allowPending);
+	}
+
+	private static String convertLocation(String location) {
+		String newLocation = location;
+		if (location.matches("[a-zA-Z]:/.*:.*")) { //$NON-NLS-1$
+			int columIndex = location.lastIndexOf(':');
+			String fileName = location.substring(0, columIndex);
+			fileName = Cygwin.pathToUnix(fileName);
+			String functionOrLineNumber = location.substring(columIndex + 1);
+			newLocation = fileName + ':' + functionOrLineNumber;
+		}
+		return newLocation;
+	}
+}
